# Славный Даниил Михайлович - Лабораторная работа 4

# №1

В данной ЛР есть очень подробная конкретика, сделана для того, чтоб в будущем я смог разобраться в коде.

# Поэтапоное выполнение задания:

1. Создаю сопрограмму, которая будет возвращать список чисел Фибоначчи до заданного числа n элементов.
2. Использую генератор для вычисления последовательности Фибоначчи.
3. Проверяю результат работы с помощью тестов.

# Про задание:

1. Последовательность Фибоначчи — это ряд чисел, где каждое последующее число является суммой двух предыдущих:
* Начинается с [0, 1].
* Следующие числа: 0, 1, 1, 2, 3, 5, 8, 13, ...

2. Генератор — функция, которая возвращает последовательность значений при вызове **yield**. Генератор запоминает свое состояние между вызовами, что позволяет сохранять промежуточные значения.
3. Сопрограмма (корутина) — особый тип функции, который может приостанавливать и возобновлять свое выполнение, что позволяет отправлять значения в корутину и получать значения из нее.

# Уточнения в коде: 

1. Функция fib_elem_gen (Генератор чисел Фибоначчи)

```

def fib_elem_gen():
    """Генератор, возвращающий элементы ряда Фибоначчи"""
    a = 0
    b = 1
    while True:
        yield a
        res = a + b
        a = b
        b = res
```

* **fib_elem_gen** — это генератор, который создает числа Фибоначчи по одному при каждом вызове **yield**.
* **yield** **a** возвращает текущее значение **a**.
* После **yield**, значения **a** и **b** обновляются: a принимает значение **b**, а **b** становится суммой предыдущих **a** и **b**.

2. Функция my_genn (Сопрограмма для создания списка чисел Фибоначчи)

```
def my_genn():
    """Сопрограмма, которая возвращает первые n элементов ряда Фибоначчи."""
    while True:
        number_of_fib_elem = yield  
        fib_gen = fib_elem_gen()  
        l = list(itertools.islice(fib_gen, number_of_fib_elem))  
        yield l  

```

* my_genn — это сопрограмма, которая создает список чисел Фибоначчи заданной длины n.
* Сопрограмма ожидает, что в нее будет отправлено значение n с помощью send.
* Получив n, сопрограмма:
  * Инициализирует генератор fib_elem_gen, который генерирует числа Фибоначчи.
  * С помощью itertools.islice извлекает первые n чисел и сохраняет их в список l.
  * Возвращает список l через yield, который содержит первые n чисел Фибоначчи.

3. Функция fib_coroutine (Обёртка для инициализации сопрограммы)

```
def fib_coroutine(g):
    @functools.wraps(g)
    def inner(*args, **kwargs):
        gen = g(*args, **kwargs)
        next(gen)  # Инициализируем сопрограмму
        return gen
    return inner
```

* fib_coroutine — обёртка, которая автоматически инициализирует сопрограмму my_genn.
* Обычно, для инициализации сопрограммы необходимо сначала вызвать send(None) или next(gen), иначе она не примет значения.
* Функция fib_coroutine выполняет эту инициализацию, вызывая next(gen) сразу после создания экземпляра сопрограммы.
* Это позволяет сразу использовать send с конкретным значением n (например, gen.send(3)), не вызывая send(None) вручную.

4. Запуск и тестирование в gen_fib.py

* Этот файл содержит тесты для проверки корректности работы сопрограммы my_genn.
* Каждый тест создает новый экземпляр my_genn и проверяет, возвращает ли он ожидаемую последовательность для различных значений n.

# Запуск и тест программы: 

1. Зпуск программы:

```
python gen_fib.py
```
2. Запуск тестов:

```
pytest test_fib.py
```

# Результаты: 

* Сопрограмма, создающая последовательность Фибоначчи.

```
PS C:\home\study\prog5\lr4> pytest .\test_fib.py
================================================================== test session starts ===================================================================
platform win32 -- Python 3.12.5, pytest-8.3.2, pluggy-1.5.0
rootdir: C:\home\study\prog5\lr4
collected 6 items

test_fib.py ......                                                                                                                                  [100%]

=================================================================== 6 passed in 0.02s ====================================================================
PS C:\home\study\prog5\lr4>
```


# №2

1. Мы создадим класс **FibonacchiLst**, который будет работать как итератор для списка чисел.
2. Класс будет получать на вход список чисел и проверять, какие из них относятся к ряду Фибоначчи.
3. Когда мы начнём перебирать элементы через этот класс, он будет возвращать только те числа из списка, которые принадлежат ряду Фибоначчи.
4. Я могу создать объект класса, передав ему список, а затем либо перебирать элементы по одному, либо сразу получить все подходящие элементы в виде нового списка.

```
class FibonacchiLst:
    def __init__(self, lst):
        self.lst = lst
        self.idx = 0
        self.fib_set = self._generate_fibonacci_set(max(lst))
    
    def _generate_fibonacci_set(self, n):
        fib_set = set()
        a, b = 0, 1
        while a <= n:
            fib_set.add(a)
            a, b = b, a + b
        return fib_set
    
    def __iter__(self):
        return self
    
    def __next__(self):
        while self.idx < len(self.lst):
            num = self.lst[self.idx]
            self.idx += 1
            if num in self.fib_set:
                return num
        raise StopIteration

lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1]
fib_iterator = FibonacchiLst(lst)
print(list(fib_iterator))

```
